{
  "name": "deglobalify",
  "version": "0.2.0",
  "description": "A browerify transform to stops 3rd party javascript modules writing to the global window object, and to return a module.exports object instead.",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/eugeneware/deglobalify"
  },
  "keywords": [
    "browserify",
    "global",
    "globals",
    "transform",
    "window"
  ],
  "author": {
    "name": "Eugene Ware",
    "email": "eugene@noblesamurai.com"
  },
  "license": "BSD",
  "devDependencies": {
    "domready": "~0.2.13",
    "debowerify": "0.3.0"
  },
  "dependencies": {
    "through": "~2.3.4",
    "falafel": "~0.3.1",
    "escodegen": "0.0.28"
  },
  "readme": "# deglobalify\n\nSick of client javascript modules adding global properties to the ```window``` object?\n\nThis [browserify](https://github.com/substack/node-browserify) transform allows \nyou to pass in a second parameter to ```require()``` which is an array of\nproperties that the offending object WOULD have set on ```window``` but will\ninstead return as part of a proper ```module.exports``` object. Joy!\n\n# Installation\n\nInstall deglobalify through npm:\n\n```\n$ npm install deglobalify\n```\n\n# Example\n\n## The old and bad way...\n\nSay you have this bad client module that pollutes the global ```window``` object:\n\n``` js\n// /public/scripts/vendor/badmodule.js\nwindow.myfunc = function() { return 42; };\n```\n\nYou include it in your browserify code:\n\n```\n// /public/scripts/app.js\nvar domready = require('domready') // regular npm module\n  , badmodule = require('./vendor/badmodule.js'); // returns undefined\n\ndomready(function () {\n  console.log(myfunc());        // prints 42 (global alert!)\n  console.log(window.myfunc()); // prints 42 (global alert!)\n});\n```\n\nBecause the bad module pollutes the ```window``` object, you need to get access\nto the ```myfunc``` function by referencing the window object.\n\n## The better deglobalify way\n\nOnce you know what global ```window``` properties the bad module is clobbering,\nyou can pass it into the ```require``` function as a list of of properties like\nso:\n\n``` js\n// /public/scripts/app.js\nvar domready = require('domready') // regular npm module\n  , badmodule = require('./vendor/badmodule.js', ['myfunc']); // returns an exports object\n\nvar myfunc = badmodule.myfunc; // myfunc is an export and NOT on the global window\n\ndomready(function () {\n  console.log(myfunc());        // prints 42 (whoohoo!)\n  console.log(window.myfunc()); // throws an exception because window.myfunc is undefined\n});\n```\n\nThen call ```browserify``` using the deglobalify transform:\n\n```\n$ browserify -t deglobalify public/scripts/app.js -o public/build/bundle.js\n```\n\nThen incude ```bundle.js``` in your HTML and you're done!\n\nThe bad module will return a regular commonjs exports object with your requested\nproperties on it!\n\nAnd the ```window``` object won't be clobbered, keeping the world a better and\nsafer place for all :-)\n\n## Using deglobalify with other transforms\n\nIf you're using deglobalify with other Browserify transforms such as\n[debowerify](https://github.com/eugeneware/debowerify) (which allows you to easily\nuse [bower](http://bower.io) components with browserify), or\n[decomponentify](https://github.com/eugeneware/decomponentify) (which allows you\nto use [component](https://github.com/component/component) components with\nbrowserify, then you are generally better to put deglobalify at the end of the\ntransform chain:\n\n```\n$ browserify -t debowerify -t deamdify -t deglobalify public/scripts/app.js -o public/build/bundle.js\n```\n\nEnjoy a global variable free existence and get a peaceful night's rest!\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/eugeneware/deglobalify/issues"
  },
  "homepage": "https://github.com/eugeneware/deglobalify",
  "_id": "deglobalify@0.2.0",
  "_from": "deglobalify@^0.2.0"
}
